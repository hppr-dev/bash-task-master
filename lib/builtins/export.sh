arguments_export() {
  EXPORT_DESCRIPTION="Export a task to a runnable bash script"
  EXPORT_REQUIREMENTS="command:c:str out:o:str"
}

task_export() {
  type task_$ARG_COMMAND &> /dev/null
  if [[ "$?" != "0" ]]
  then
    echo "No Command named $ARG_COMMAND"
    return
  fi
  echo "#!/bin/bash" > $ARG_OUT
  echo "# Autogenerated from Task Master" >> $ARG_OUT
  export_generate_args
  export_main_func
  echo "$arg_parse" >> $ARG_OUT
  echo "$code" >> $ARG_OUT
  chmod +x $ARG_OUT
}

export_generate_args() {
  arg_parse="while [[ \$# -ge 1 ]]
do
  case \$1 in"
  type arguments_$ARG_COMMAND &> /dev/null
  if [[ "$?" == "0" ]]
  then 
    arguments_$ARG_COMMAND
    reqname=${ARG_COMMAND^^}_REQUIREMENTS
    optname=${ARG_COMMAND^^}_OPTIONS
    if [[ "${SUBCOMMANDS/\|\|/}" != "$SUBCOMMANDS" ]] || [[ ! -z "${!reqname}" ]] || [[ ! -z "${!optname}" ]] 
    then
      if [[ ! -z "${!reqname}" ]]
      then
        for req in ${!reqname}
        do
          arg_spec=${req%:*}
          arg_name=${arg_spec%:*}
          long_arg="--${arg_name}"
          short_arg="-${arg_spec#*:}"
          arg_type=${req##*:}
          export_update_arg_parse
        done
      fi
      if [[ ! -z "${!optname}" ]]
      then
        for opt in ${!optname}
        do
          arg_spec=${opt%:*}
          arg_name=${arg_spec%:*}
          long_arg="--${arg_name}"
          short_arg="-${arg_spec#*:}"
          arg_type=${opt##*:}
          export_update_arg_parse
        done
      fi
      echo
    fi
    for sub in ${SUBCOMMANDS//\|/ }
    do 
      sub=${sub//-/_}
      reqname=${sub^^}_REQUIREMENTS
      optname=${sub^^}_OPTIONS
      if [[ ! -z "${!reqname}" ]]
      then
        for req in ${!reqname}
        do
          arg_spec=${req%:*}
          arg_name=${arg_spec%:*}
          long_arg="--${arg_name}"
          short_arg="-${arg_spec#*:}"
          arg_type=${req##*:}
          export_update_arg_parse
        done
      fi
      if [[ ! -z "${!optname}" ]]
      then
        for opt in ${!optname}
        do
          arg_spec=${opt%:*}
          arg_name=${arg_spec%:*}
          long_arg="--${arg_name}"
          short_arg="-${arg_spec#*:}"
          arg_type=${opt##*:}
          export_update_arg_parse
        done
      fi
    arg_parse="$arg_parse
  ${sub^^}|${sub,,})
    TASK_SUBCOMMAND=\$1
    shift
    ;;"
    done
    task help $ARG_COMMAND > $ARG_COMMAND.help
    arg_parse="$arg_parse
  -h|--help)
    echo \"$(sed "s/task $ARG_COMMAND/$ARG_OUT/" $ARG_COMMAND.help | tail -n +2)\"
    exit 0
    ;;
"
    rm $ARG_COMMAND.help
    arg_parse="$arg_parse
  *)
    echo Unrecognized argument: \$1
    ./\$(basename \"\$0\") --help
    exit 1
    ;;
  esac
done
"
  else
    echo "No arguments are defined"
    arg_parse=""
  fi
}

export_main_func() {
  echo "NOTE: Export will only search for function definitions one deep"
  code="$(type task_$ARG_COMMAND | tail -n +2)" 
  main_code=""
  while read -r line
  do
    i=$(echo "$line" | awk '{print $1}')
    utility_code="$(type "${i//;/}" 2> /dev/null | tail -n +4 | head -n -1)" &> /dev/null
    if [[ ! -z "$utility_code" ]] && [[ ! "task_$ARG_COMMAND ()*" =~ "$line" ]]
    then
      main_code="$main_code
$utility_code"
    elif [[ "task_$ARG_COMMAND ()*" =~ "$line" ]]
    then
      main_code="$main_code
exported_task ()"
    else
      main_code="$main_code
$line"
    fi
  done <<< "$code"
  # Read in exported code
  eval "$main_code"
  code="$(type exported_task | tail -n +4 | head -n -1 | sed 's/^    //')"
}

export_update_arg_parse() {
  arg_name=${arg_name//-/_}
  if [[ "$arg_type" == "bool" ]]
  then
    arg_parse="$arg_parse
  $short_arg|$long_arg)
    ARG_${arg_name^^}=T
    shift
    ;;"
  else
    arg_parse="$arg_parse
  $short_arg|$long_arg)
    ARG_${arg_name^^}=\$2
    shift
    shift
    ;;"
  fi
}

readonly -f task_export
readonly -f export_main_func
readonly -f export_generate_args
readonly -f export_update_arg_parse
